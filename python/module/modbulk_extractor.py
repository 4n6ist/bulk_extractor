#!/usr/bin/env python2
"""
Analyze drives and bulk data with bulk_extractor.  Features located and
histograms generated by bulk extractor are returned through a callback
function; it is up to the recipient to organze and store the data.  See
bulk_extractor documentation for general operating guidelines.
"""

from ctypes import *

# see also bulk_extractor_api.h

# callback type flags
API_CODE_FEATURE      =    1
API_CODE_HISTOGRAM    =    2
API_CODE_CARVED       =    3
API_CODE_FEATURELIST  =   10
API_EXCEPTION         = 1000
# scanner configuration commands
PROCESS_COMMANDS = 0 # commit pending enable/disable commands
SCANNER_DISABLE  = 1
SCANNER_ENABLE   = 2
FEATURE_DISABLE  = 3
FEATURE_ENABLE   = 4
MEMHIST_ENABLE   = 5 # in-memory histogram instead of feature file
MEMHIST_LIMIT    = 6
DISABLE_ALL      = 7
FEATURE_LIST     = 8
SCANNER_LIST     = 9

def open_handle(callback, user_arg=None):
    """Start a new bulk_extractor session with the supplied callback."""
    return lib_be.bulk_extractor_open(user_arg, callback);
def configure(handle, cmd, scanner, arg):
    """
    Configure the given handle.  Send a command with an argument to the names
    scanner.  See bulk_extractor documentation for details.
    """
    return lib_be.bulk_extractor_config(handle, cmd, scanner, arg)
def analyze_buffer(handle, buf):
    """
    Analyze the supplied buffer with bulk_extractor, returning results via the
    given handle's callback.  Buf can be either a bytearray or a string.
    """
    buf = _bytes(buf)
    return lib_be.bulk_extractor_analyze_buf(handle, buf, len(buf))
def analyze_device(handle, path, sample_rate, sample_size):
    """
    Analyze the device at the given path with bulk_extractor, returning results
    via the given handle's callback.  Sample rate is a value in (0, 1]
    indicating the fraction of the drive to analyze.  Sample size dictates the
    size of each sample.
    """
    return lib_be.bulk_extractor_analyze_dev(handle, path, sample_rate,
            sample_size)
def close_handle(handle):
    """End the given bulk_extractor session."""
    return lib_be.bulk_extractor_close(handle)

def _bytes(value, encoding='utf-8'):
    #if type(value) == str:
        #return bytearray(value, encoding)
    return value


lib_be = cdll.LoadLibrary("bulk_extractor.so")

# handle is opaque to python module for simplicity and loose coupling
BeHandle = c_void_p

BeCallback = CFUNCTYPE(
        c_int,    # return type

        c_void_p, # arbitrary user data
        c_uint32, # callback type flags
        c_uint64, # multi-use callback argument
        c_char_p, # feature recorder name or other
        c_char_p, # feature forensic path
        c_char_p, # feature data
        c_size_t, # feature length
        c_char_p, # feature context data
        c_size_t, # context length
        )

lib_be.bulk_extractor_open.restype = BeHandle
lib_be.bulk_extractor_open.argtypes = [
        c_void_p,   # arbitrary user data
        BeCallback, # callback for the duration of the handle
        ]
lib_be.bulk_extractor_config.restype = None
lib_be.bulk_extractor_config.argtypes = [
        BeHandle, # session obtained from bulk_extractor_open
        c_uint32, # configuration command
        c_char_p, # affected scanner
        c_int64,  # configuration argument
        ]
lib_be.bulk_extractor_analyze_buf.restype = c_int
lib_be.bulk_extractor_analyze_buf.argtypes = [
        BeHandle, # session obtained from bulk_extractor_open
        c_char_p, # the buffer
        c_size_t, # buffer length
        ]
lib_be.bulk_extractor_analyze_dev.restype = c_int
lib_be.bulk_extractor_analyze_dev.argtypes = [
        BeHandle, # session obtained from bulk_extractor_open
        c_char_p, # path to the device
        c_float,  # fraction of the drive to sample
        c_int,    # size of each sample (in bytes?)
        ]
lib_be.bulk_extractor_close.restype = c_int
lib_be.bulk_extractor_close.argtypes = [
        BeHandle, # session obtained from bulk_extractor_open
        ]

def main():
    def callback(user, flag, arg, recorder, fpath, feature, feature_len,
            context, context_len):
        print("hello, world!")
        return 0
    handle = open_handle(callback)
    analyze_buffer(handle, "")
    configure(handle, FEATURE_LIST, "", 0)
    close_handle(handle)

if __name__ == "__main__":
    main()
